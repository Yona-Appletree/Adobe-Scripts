//// created by JK Keller, dilettante coder// http://jk-keller.com//// I WOULDN'T USE THIS AS IS. PROCESSING IS SO MUCH BETTER AT THIS MANIPULATION...// Mountain shift// if the diff of colors is great enough,// get the vert location// then select the column// then shift up or down// then make a txt file of numbers// enable double clicking from the Macintosh Finder or the Windows Explorer#target photoshop// in case we double clicked the fileapp.bringToFront();var docRef = app.activeDocumentvar activeLayerName = docRef.activeLayer.name;app.preferences.rulerUnits = Units.PIXELS app.displayDialogs = DialogModes.NOdocRef.activeLayer = docRef.layers["guide"];// starting valuesvar checkColor = new SolidColor();checkColor.rgb.red   = 255;checkColor.rgb.green = 255;checkColor.rgb.blue  = 255;//var docWidth = 10;var docWidth = docRef.width*1;var docHeight = docRef.height*1;////////////////// check////////////////// checkvar aHeights = new Array();var startColVal = prompt("y location to begin?", "0")*1;var horizonVal = prompt("x location of horizon line?", "4068")*1;var jStart = horizonVal-20;var jStartHold = jStart;var jEnd = horizonVal+20;var jEndHold = jEnd;var jStartDirection = "downStart";var jEndDirection = "upEnd";// get pixel color (from xbytor http://www.ps-scripts.com/bb/viewtopic.php?=&p=3078)function getColorAt(pDoc, x, y) {	selectBounds(pDoc, [x, y, x+1, y+1]);	var pColor = new SolidColor();   	pColor.rgb.red   = findPV(pDoc.channels["Red"].histogram);	pColor.rgb.green = findPV(pDoc.channels["Green"].histogram)	pColor.rgb.blue  = findPV(pDoc.channels["Blue"].histogram);	pDoc.selection.deselect(); // or, even better, undo		return pColor;};function selectBounds(pDoc, pRect) {	pDoc.selection.select([[ pRect[0], pRect[1] ],[ pRect[2], pRect[1] ],[ pRect[2], pRect[3] ],[ pRect[0], pRect[3] ]]);}function findPV(pHist) {	for (var i = 0; i <= 255; i++ ) {		if (pHist[i]) { return i; }	}	return 0;}for (var i=startColVal; i<docWidth; i++) {//for (var i=26; i<30; i++) {	docRef.activeLayer = docRef.layers["guide"];	if (jStartDirection == "upStart") {		for (var j=jStart; j>0; j--) {			var tColor = getColorAt(docRef, i, j);			if (tColor.rgb.red != checkColor.rgb.red || tColor.rgb.green != checkColor.rgb.green || tColor.rgb.blue != checkColor.rgb.blue) {				jStart = j;				jStartDirection = "downStart";				break;			};		};	};	for (var j=jStart; j<docHeight; j++) {		var tColor = getColorAt(docRef, i, j);		if (tColor.rgb.red == checkColor.rgb.red && tColor.rgb.green == checkColor.rgb.green && tColor.rgb.blue == checkColor.rgb.blue) {			jStartHold = j;			jStart = j;			jStartDirection = "upStart";			break;		};	};	if (jEndDirection == "downEnd") {		for (var j=jEnd; j<docHeight; j++) {			var tColor = getColorAt(docRef, i, j);			if (tColor.rgb.red != checkColor.rgb.red || tColor.rgb.green != checkColor.rgb.green || tColor.rgb.blue != checkColor.rgb.blue) {				jEnd = j;				jEndDirection = "upEnd";				break;			};		};	};	for (var j=jEnd; j>0; j--) {		var tColor = getColorAt(docRef, i, j);		if (tColor.rgb.red == checkColor.rgb.red && tColor.rgb.green == checkColor.rgb.green && tColor.rgb.blue == checkColor.rgb.blue) {			jEndHold = j;			jEnd = j;			jEndDirection = "downEnd";			break;		};	};	//aHeights.push(j);	var xMove = (horizonVal - jStartHold) + (horizonVal - jEndHold)	//alert("xMove:"+xMove+","+"horizonVal:"+horizonVal+","+"docHeight:"+docHeight+","+"i:"+i+",");				docRef.activeLayer = docRef.layers["image"];	selectBounds(docRef, [i, 0, i+1, docHeight]);	docRef.selection.translate(0,xMove);//	docRef.selection.deselect();	selectBounds(docRef, [i, 0, i+1, docHeight]);			try {				docRef.selection.rotate(360);			} catch(errorr) {				docRef.activeLayer = docRef.layers["image2"];				selectBounds(docRef, [i+1, 0, i+2, docHeight]);				docRef.selection.translate(0,xMove);//				alert ("maybe?") ;			}	selectBounds(docRef, [i, 0, i+1, docHeight]);			try {				docRef.selection.rotate(360);			} catch(errorr) {				docRef.activeLayer = docRef.layers["image3"];				selectBounds(docRef, [i+2, 0, i+3, docHeight]);				docRef.selection.translate(0,xMove);//				alert ("maybe?") ;			}								// for coins (backside)		/*			docRef.activeLayer = docRef.layers["back"];	selectBounds(docRef, [i, 0, i+1, docHeight]);	docRef.selection.translate(0,xMove);//	docRef.selection.deselect();	selectBounds(docRef, [i, 0, i+1, docHeight]);			try {				docRef.selection.rotate(360);			} catch(errorr) {				docRef.activeLayer = docRef.layers["back2"];				selectBounds(docRef, [i-1, 0, i, docHeight]);				docRef.selection.translate(0,xMove);//				alert ("maybe?") ;			}	selectBounds(docRef, [i, 0, i+1, docHeight]);			try {				docRef.selection.rotate(360);			} catch(errorr) {				docRef.activeLayer = docRef.layers["back3"];				selectBounds(docRef, [i-2, 0, i-1, docHeight]);				docRef.selection.translate(0,xMove);//				alert ("maybe?") ;			}	//docRef.layers["counter"+(i-1)].name = "counter"+i;*/};alert("done?!!?");// docRef.close();