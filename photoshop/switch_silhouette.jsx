// Switch Profiles v.9//// created by JK Keller, dilettante coder// http://jk-keller.com//// I WOULDN'T USE THIS AS IS. PROCESSING IS SO MUCH BETTER AT THIS MANIPULATION...// Script takes the profile of one image and switches it with onother// Oh, great description dumbass// enable double clicking from the Macintosh Finder or the Windows Explorer #target photoshop// in case we double clicked the file app.bringToFront();var docRef = app.activeDocumentvar activeLayerName = docRef.activeLayer.name;app.preferences.rulerUnits = Units.PIXELS app.displayDialogs = DialogModes.NOdocRef.activeLayer = docRef.layers["guideFrom"];// starting valuesvar checkColor = new SolidColor();checkColor.rgb.red   = 255;checkColor.rgb.green = 255;checkColor.rgb.blue  = 255;//var docWidth = 10;var docWidth = docRef.width;var docHeight = docRef.height;////////////////// check////////////////// checkvar aHeights = new Array();// Start in the black area!!!!!var startX = prompt("column to start at?", "900")*1;var horizonVal = prompt("x location of horizon line?", "2314")*1;var jFromStart = horizonVal+20;var jFromStartHold = jFromStart;var jToStart = horizonVal+20;var jToStartHold = jToStart;var jFromStartDirection = "upFrom";var jToStartDirection = "upTo";// get pixel color (from xbytor http://www.ps-scripts.com/bb/viewtopic.php?=&p=3078)function getColorAt(pDoc, x, y) {	selectBounds(pDoc, [x, y, x+1, y+1]);	var pColor = new SolidColor();   	pColor.rgb.red   = findPV(pDoc.channels["Red"].histogram);	pColor.rgb.green = findPV(pDoc.channels["Green"].histogram)	pColor.rgb.blue  = findPV(pDoc.channels["Blue"].histogram);	pDoc.selection.deselect(); // or, even better, undo		return pColor;};function selectBounds(pDoc, pRect) {	pDoc.selection.select([[ pRect[0], pRect[1] ],[ pRect[2], pRect[1] ],[ pRect[2], pRect[3] ],[ pRect[0], pRect[3] ]]);}function findPV(pHist) {	for (var i = 0; i <= 255; i++ ) {		if (pHist[i]) { return i; }	}	return 0;}for (var i=startX; i<docWidth; i++) {	docRef.layers["guideFrom"].visible = true;	docRef.activeLayer = docRef.layers["guideFrom"];	if (jFromStartDirection == "upFrom") {		for (var j=jFromStart; j>0; j--) {			var tColor = getColorAt(docRef, i, j);			if (tColor.rgb.red == checkColor.rgb.red && tColor.rgb.green == checkColor.rgb.green && tColor.rgb.blue == checkColor.rgb.blue) {				jFromStart = j;				jFromStartDirection = "downFrom";				break;			};		};	};	for (var j=jFromStart; j<docHeight; j++) {		var tColor = getColorAt(docRef, i, j);		if (tColor.rgb.red != checkColor.rgb.red || tColor.rgb.green != checkColor.rgb.green || tColor.rgb.blue != checkColor.rgb.blue) {			jFromStartHold = j;			jFromStart = j;			jFromStartDirection = "upFrom";			break;		};	};	docRef.layers["guideFrom"].visible = false;	docRef.activeLayer = docRef.layers["guideTo"];	if (jToStartDirection == "upTo") {		for (var j=jToStart; j>0; j--) {			var tColor = getColorAt(docRef, i, j);			if (tColor.rgb.red == checkColor.rgb.red && tColor.rgb.green == checkColor.rgb.green && tColor.rgb.blue == checkColor.rgb.blue) {				jToStart = j;				jToStartDirection = "downTo";				break;			};		};	};	for (var j=jToStart; j<docHeight; j++) {		var tColor = getColorAt(docRef, i, j);		if (tColor.rgb.red != checkColor.rgb.red || tColor.rgb.green != checkColor.rgb.green || tColor.rgb.blue != checkColor.rgb.blue) {			jToStartHold = j;			jToStart = j;			jToStartDirection = "upTo";			break;		};	};	//aHeights.push(j);	var xMove = jToStartHold - jFromStartHold				docRef.activeLayer = docRef.layers["imageFrom"];	selectBounds(docRef, [i, 0, i+1, docHeight]);	docRef.selection.translate(0,xMove);	docRef.selection.deselect();	// ERROR CHECK for empty pixels			selectBounds(docRef, [i, 0, i+1, docHeight]);			try {				docRef.selection.rotate(360);			} catch(errorr) {				docRef.activeLayer = docRef.layers["imageFrom2"];				selectBounds(docRef, [i+1, 0, i+2, docHeight]);				docRef.selection.translate(0,xMove);			}	// END ERROR CHECK for empty pixels	// ERROR CHECK for empty pixels			selectBounds(docRef, [i, 0, i+1, docHeight]);			try {				docRef.selection.rotate(360);			} catch(errorr) {				docRef.activeLayer = docRef.layers["imageFrom3"];				selectBounds(docRef, [i+2, 0, i+3, docHeight]);				docRef.selection.translate(0,xMove);			}	// END ERROR CHECK for empty pixels	var xMoveTo =  jFromStartHold - jToStartHold				docRef.activeLayer = docRef.layers["imageTo"];	selectBounds(docRef, [i, 0, i+1, docHeight]);	docRef.selection.translate(0,xMoveTo);	docRef.selection.deselect();	// ERROR CHECK for empty pixels			selectBounds(docRef, [i, 0, i+1, docHeight]);			try {				docRef.selection.rotate(360);			} catch(errorr) {				docRef.activeLayer = docRef.layers["imageTo2"];				selectBounds(docRef, [i+1, 0, i+2, docHeight]);				docRef.selection.translate(0,xMoveTo);			}	// END ERROR CHECK for empty pixels	// ERROR CHECK for empty pixels			selectBounds(docRef, [i, 0, i+1, docHeight]);			try {				docRef.selection.rotate(360);			} catch(errorr) {				docRef.activeLayer = docRef.layers["imageTo3"];				selectBounds(docRef, [i+2, 0, i+3, docHeight]);				docRef.selection.translate(0,xMoveTo);			}	// END ERROR CHECK for empty pixels};alert("done?!!?");// docRef.close();